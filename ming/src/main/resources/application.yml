spring:
  datasource:
    driver-class-name: org.postgresql.Driver
    url: "jdbc:postgresql://localhost:5432/postgres"
    username: "postgres"
    password: "ming"
    #使用 hikari连接池
    type: com.zaxxer.hikari.HikariDataSource
    hikari:
      minimum-idle: 5
      maximum-pool-size: 15
      auto-commit: true
      idle-timeout: 30000
      pool-name: "ming-hikari"
      max-lifetime: 1800000
      connection-timeout: 30000
      connection-test-query: "select 1;"
  jpa:
    # 是否打印sql
    show-sql: false
    hibernate:
      naming:
        #entity使用驼峰命名  数据表使用下划线命名
        physical-strategy: org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy
      #create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。
      #create-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。
      #update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。
      #validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。
      #none：不进行任何处理
      ddl-auto: create
    #关闭hibernate 启动的时候检测数据库元数据 避免报错:Disabling contextual LOB creation as createClob() method threw error : java.lang.reflect.InvocationTargetException
    #https://stackoverflow.com/questions/4588755/disabling-contextual-lob-creation-as-createclob-method-threw-error
    properties:
      #"hibernate.temp.use_jdbc_metadata_defaults=false"
      hibernate:
        temp:
          use_jdbc_meatdata_defaults: false
        jdbc:
          lob:
            non_contextual_creation: true
    open-in-view: false